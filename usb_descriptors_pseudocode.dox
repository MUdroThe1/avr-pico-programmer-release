/**
@page usb_descriptors_pseudocode Pseudocode for usb_descriptors.c

This page provides pseudocode for all functions and data structures in the
usb_descriptors.c module, which defines USB descriptors for the CDC device.

@section usb_descriptors_overview Overview

This module defines the USB descriptors that identify the device to the USB host.
The device presents itself as a USB CDC ACM (Communications Device Class, Abstract
Control Model) device, creating a virtual serial port on the host system.

@section usb_descriptors_constants Constants and Definitions

@code{.unparsed}
// Vendor and Product IDs
VENDOR_ID  = 0x2E8A   // Raspberry Pi
PRODUCT_ID = 0x000A   // Generic CDC

// Interface numbers
ITF_NUM_CDC      = 0   // CDC communication interface
ITF_NUM_CDC_DATA = 1   // CDC data interface
ITF_NUM_TOTAL    = 2   // Total interface count

// Endpoint addresses
EPNUM_CDC_NOTIF = 0x81   // Notification IN endpoint
EPNUM_CDC_OUT   = 0x02   // Data OUT endpoint (host to device)
EPNUM_CDC_IN    = 0x82   // Data IN endpoint (device to host)
@endcode

@section usb_descriptors_structures Data Structures

@subsection device_descriptor_pseudo Device Descriptor

@code{.unparsed}
STRUCTURE device_descriptor:
    bLength            = 18           // Size of descriptor in bytes
    bDescriptorType    = DEVICE       // Device descriptor type
    bcdUSB             = 0x0200       // USB 2.0
    bDeviceClass       = MISC         // Miscellaneous device class
    bDeviceSubClass    = COMMON       // Common subclass
    bDeviceProtocol    = IAD          // Interface Association Descriptor protocol
    bMaxPacketSize0    = 64           // Max packet size for endpoint 0
    idVendor           = 0x2E8A       // Raspberry Pi vendor ID
    idProduct          = 0x000A       // Generic CDC product ID
    bcdDevice          = 0x0100       // Device version 1.0
    iManufacturer      = 1            // Index of manufacturer string
    iProduct           = 2            // Index of product string
    iSerialNumber      = 3            // Index of serial number string
    bNumConfigurations = 1            // One configuration
END STRUCTURE
@endcode

@subsection config_descriptor_pseudo Configuration Descriptor

@code{.unparsed}
STRUCTURE configuration_descriptor:
    // Configuration header
    config_number    = 1
    interface_count  = 2              // CDC requires 2 interfaces
    string_index     = 0
    total_length     = CONFIG_DESC_LEN + CDC_DESC_LEN
    attributes       = REMOTE_WAKEUP  // Supports remote wakeup
    max_power        = 100 mA         // Power consumption
    
    // CDC descriptor block (generated by TUD_CDC_DESCRIPTOR macro)
    // Contains:
    //   - Interface Association Descriptor (IAD)
    //   - CDC Communication Interface
    //     - Header Functional Descriptor
    //     - Call Management Functional Descriptor
    //     - ACM Functional Descriptor
    //     - Union Functional Descriptor
    //     - Notification endpoint (IN, 8 bytes)
    //   - CDC Data Interface
    //     - Data OUT endpoint (64 bytes)
    //     - Data IN endpoint (64 bytes)
END STRUCTURE
@endcode

@subsection string_descriptors_pseudo String Descriptors

@code{.unparsed}
ARRAY string_descriptors:
    [0] = Language ID (0x0409 = US English)
    [1] = "EVAbits"           // Manufacturer name
    [2] = "RP2040 AVR ISP"    // Product name
    [3] = "0001"              // Serial number
    [4] = "CDC"               // CDC interface name
END ARRAY
@endcode

@section usb_descriptors_functions Function Pseudocode

@subsection tud_descriptor_device_cb_pseudo tud_descriptor_device_cb()

@code{.unparsed}
FUNCTION tud_descriptor_device_cb() -> byte_pointer
    // TinyUSB callback to provide device descriptor
    // Called during USB enumeration to identify the device
    
    RETURN pointer_to(device_descriptor)
END FUNCTION
@endcode

@subsection tud_descriptor_configuration_cb_pseudo tud_descriptor_configuration_cb(index)

@code{.unparsed}
FUNCTION tud_descriptor_configuration_cb(index) -> byte_pointer
    // TinyUSB callback to provide configuration descriptor
    // Called during enumeration to describe interfaces and endpoints
    
    // Note: index parameter ignored (only one configuration supported)
    
    RETURN pointer_to(configuration_descriptor)
END FUNCTION
@endcode

@subsection tud_descriptor_string_cb_pseudo tud_descriptor_string_cb(index, langid)

@code{.unparsed}
FUNCTION tud_descriptor_string_cb(index, langid) -> uint16_pointer
    // TinyUSB callback to provide string descriptors
    // Returns UTF-16LE encoded strings for device identification
    
    // Note: langid parameter ignored (only English supported)
    
    IF index == 0:
        // Return language ID descriptor
        _desc_str[1] = 0x0409   // US English
        _desc_str[0] = (STRING_DESCRIPTOR_TYPE << 8) OR 4  // Length
        RETURN _desc_str
    END IF
    
    IF index >= COUNT(string_descriptors):
        RETURN NULL  // Invalid index
    END IF
    
    // Get source string
    source_string = string_descriptors[index]
    char_count = LENGTH(source_string)
    
    // Limit to 31 characters (USB string descriptor limit)
    IF char_count > 31:
        char_count = 31
    END IF
    
    // Convert ASCII to UTF-16LE
    FOR i FROM 0 TO char_count - 1:
        _desc_str[1 + i] = source_string[i]  // ASCII to UTF-16
    END FOR
    
    // Set descriptor header (type and length)
    total_length = 2 + (2 * char_count)  // Header + UTF-16 characters
    _desc_str[0] = (STRING_DESCRIPTOR_TYPE << 8) OR total_length
    
    RETURN _desc_str
END FUNCTION
@endcode

@section usb_descriptors_flow USB Enumeration Flow

@code{.unparsed}
USB ENUMERATION SEQUENCE:

1. Host detects device connection
   
2. Host requests DEVICE DESCRIPTOR
   -> tud_descriptor_device_cb() returns device_descriptor
   -> Host learns VID/PID, USB version, device class
   
3. Host requests CONFIGURATION DESCRIPTOR
   -> tud_descriptor_configuration_cb() returns config_descriptor
   -> Host learns interfaces, endpoints, power requirements
   
4. Host requests STRING DESCRIPTORS
   -> tud_descriptor_string_cb(1) returns "EVAbits" (manufacturer)
   -> tud_descriptor_string_cb(2) returns "RP2040 AVR ISP" (product)
   -> tud_descriptor_string_cb(3) returns "0001" (serial number)
   
5. Host loads CDC ACM driver
   -> Virtual serial port created (e.g., /dev/ttyACM0 or COMx)
   
6. Device ready for communication
@endcode

@section usb_descriptors_endpoint_usage Endpoint Usage

@code{.unparsed}
ENDPOINT CONFIGURATION:

Endpoint 0x00/0x80 (Control):
    - Standard USB control transfers
    - Descriptor requests handled here
    
Endpoint 0x81 (Notification IN):
    - CDC notification messages
    - Used for line state changes
    - Max packet size: 8 bytes
    
Endpoint 0x02 (Data OUT):
    - Bulk data from host to device
    - STK500v1 commands received here
    - Max packet size: 64 bytes
    
Endpoint 0x82 (Data IN):
    - Bulk data from device to host
    - STK500v1 responses sent here
    - Max packet size: 64 bytes
@endcode

*/
