<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: pico/avrprog.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_729958c98a37b673f34d84c25e02f88b.html">pico</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">avrprog.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>AVR ISP (In-System Programming) implementation for Raspberry Pi Pico.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="avrprog_8h_source.html">avrprog.h</a>&quot;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;pico/stdlib.h&gt;</code><br />
<code>#include &lt;hardware/spi.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for avrprog.c:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="avrprog_8c__incl.svg" width="476" height="183"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aed5be6964366f7702c0df0572f94b601" id="r_aed5be6964366f7702c0df0572f94b601"><td class="memItemLeft" align="right" valign="top"><a id="aed5be6964366f7702c0df0572f94b601" name="aed5be6964366f7702c0df0572f94b601"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>mosi_pin</b>&#160;&#160;&#160;19     /* Master Out Slave In - data from Pico to AVR */</td></tr>
<tr class="separator:aed5be6964366f7702c0df0572f94b601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f383f544cde282d909c146045e254c2" id="r_a2f383f544cde282d909c146045e254c2"><td class="memItemLeft" align="right" valign="top"><a id="a2f383f544cde282d909c146045e254c2" name="a2f383f544cde282d909c146045e254c2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>sck_pin</b>&#160;&#160;&#160;18      /* Serial Clock - generated by Pico (master) */</td></tr>
<tr class="separator:a2f383f544cde282d909c146045e254c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb1352c6aba4f5a311a066f24ad296a" id="r_aeeb1352c6aba4f5a311a066f24ad296a"><td class="memItemLeft" align="right" valign="top"><a id="aeeb1352c6aba4f5a311a066f24ad296a" name="aeeb1352c6aba4f5a311a066f24ad296a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>miso_pin</b>&#160;&#160;&#160;16     /* Master In Slave Out - data from AVR to Pico */</td></tr>
<tr class="separator:aeeb1352c6aba4f5a311a066f24ad296a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc620edf9e32ecf8e88e344f67266d8d" id="r_adc620edf9e32ecf8e88e344f67266d8d"><td class="memItemLeft" align="right" valign="top"><a id="adc620edf9e32ecf8e88e344f67266d8d" name="adc620edf9e32ecf8e88e344f67266d8d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>reset_pin</b>&#160;&#160;&#160;17    /* Active-low reset line to hold AVR in programming mode */</td></tr>
<tr class="separator:adc620edf9e32ecf8e88e344f67266d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51aede60d5bdd96ebd1274f872bfa305" id="r_a51aede60d5bdd96ebd1274f872bfa305"><td class="memItemLeft" align="right" valign="top"><a id="a51aede60d5bdd96ebd1274f872bfa305" name="a51aede60d5bdd96ebd1274f872bfa305"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>power_pin</b>&#160;&#160;&#160;0     /* Optional power control for target (not currently used) */</td></tr>
<tr class="separator:a51aede60d5bdd96ebd1274f872bfa305"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aee655c0c64cc3dea8a411bec014c0cdf" id="r_aee655c0c64cc3dea8a411bec014c0cdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avrprog_8c.html#aee655c0c64cc3dea8a411bec014c0cdf">avr_read_signature</a> (uint8_t *signature)</td></tr>
<tr class="memdesc:aee655c0c64cc3dea8a411bec014c0cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the 3-byte device signature from the AVR.  <br /></td></tr>
<tr class="separator:aee655c0c64cc3dea8a411bec014c0cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd14f08aed255cec267160466dcc769f" id="r_afd14f08aed255cec267160466dcc769f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avrprog_8c.html#afd14f08aed255cec267160466dcc769f">avr_spi_init</a> ()</td></tr>
<tr class="memdesc:afd14f08aed255cec267160466dcc769f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the SPI interface for AVR ISP communication.  <br /></td></tr>
<tr class="separator:afd14f08aed255cec267160466dcc769f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f4037696b714b05489fda5207a0231" id="r_a20f4037696b714b05489fda5207a0231"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avrprog_8c.html#a20f4037696b714b05489fda5207a0231">avr_reset</a> ()</td></tr>
<tr class="memdesc:a20f4037696b714b05489fda5207a0231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a hardware reset pulse on the AVR target.  <br /></td></tr>
<tr class="separator:a20f4037696b714b05489fda5207a0231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc4cfb84dfc8dce803ec1517c6bf00b" id="r_acfc4cfb84dfc8dce803ec1517c6bf00b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avrprog_8c.html#acfc4cfb84dfc8dce803ec1517c6bf00b">avr_enter_programming_mode</a> ()</td></tr>
<tr class="memdesc:acfc4cfb84dfc8dce803ec1517c6bf00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter AVR Serial Programming mode.  <br /></td></tr>
<tr class="separator:acfc4cfb84dfc8dce803ec1517c6bf00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2192cd51a3038bb9b1168ca1017e2582" id="r_a2192cd51a3038bb9b1168ca1017e2582"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avrprog_8c.html#a2192cd51a3038bb9b1168ca1017e2582">avr_leave_programming_mode</a> ()</td></tr>
<tr class="memdesc:a2192cd51a3038bb9b1168ca1017e2582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit AVR Serial Programming mode.  <br /></td></tr>
<tr class="separator:a2192cd51a3038bb9b1168ca1017e2582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06815cdb67fe3043b8de01c367b8ca8d" id="r_a06815cdb67fe3043b8de01c367b8ca8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avrprog_8c.html#a06815cdb67fe3043b8de01c367b8ca8d">avr_erase_memory</a> ()</td></tr>
<tr class="memdesc:a06815cdb67fe3043b8de01c367b8ca8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a Chip Erase operation on the AVR target.  <br /></td></tr>
<tr class="separator:a06815cdb67fe3043b8de01c367b8ca8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fea5f4158f65ac28f33dcb868834a8" id="r_ad5fea5f4158f65ac28f33dcb868834a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avrprog_8c.html#ad5fea5f4158f65ac28f33dcb868834a8">avr_write_temporary_buffer</a> (uint16_t word_address, uint8_t low_byte, uint8_t high_byte)</td></tr>
<tr class="memdesc:ad5fea5f4158f65ac28f33dcb868834a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a word (low and high bytes) to the temporary page buffer.  <br /></td></tr>
<tr class="separator:ad5fea5f4158f65ac28f33dcb868834a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f08500e8dc958684c90401d71ee4e79" id="r_a3f08500e8dc958684c90401d71ee4e79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avrprog_8c.html#a3f08500e8dc958684c90401d71ee4e79">avr_write_temporary_buffer_16</a> (uint16_t word_address, uint16_t word)</td></tr>
<tr class="memdesc:a3f08500e8dc958684c90401d71ee4e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 16-bit word to the temporary page buffer.  <br /></td></tr>
<tr class="separator:a3f08500e8dc958684c90401d71ee4e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f5de25e840fe820d2c63b3c77f2b60" id="r_ac2f5de25e840fe820d2c63b3c77f2b60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avrprog_8c.html#ac2f5de25e840fe820d2c63b3c77f2b60">avr_flash_program_memory</a> (uint16_t word_address)</td></tr>
<tr class="memdesc:ac2f5de25e840fe820d2c63b3c77f2b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash the temporary page buffer to program memory.  <br /></td></tr>
<tr class="separator:ac2f5de25e840fe820d2c63b3c77f2b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4001d4bd58bb212246ad73ea16c7718a" id="r_a4001d4bd58bb212246ad73ea16c7718a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avrprog_8c.html#a4001d4bd58bb212246ad73ea16c7718a">avr_read_program_memory_low_byte</a> (uint16_t word_address)</td></tr>
<tr class="memdesc:a4001d4bd58bb212246ad73ea16c7718a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the low byte of a program memory word.  <br /></td></tr>
<tr class="separator:a4001d4bd58bb212246ad73ea16c7718a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab140e6a9e9d9a0b28c1669db8f4ef47e" id="r_ab140e6a9e9d9a0b28c1669db8f4ef47e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avrprog_8c.html#ab140e6a9e9d9a0b28c1669db8f4ef47e">avr_read_program_memory_high_byte</a> (uint16_t word_address)</td></tr>
<tr class="memdesc:ab140e6a9e9d9a0b28c1669db8f4ef47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the high byte of a program memory word.  <br /></td></tr>
<tr class="separator:ab140e6a9e9d9a0b28c1669db8f4ef47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b159c70569ac198acd7cd6a46a8d30c" id="r_a4b159c70569ac198acd7cd6a46a8d30c"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avrprog_8c.html#a4b159c70569ac198acd7cd6a46a8d30c">avr_read_program_memory</a> (uint16_t word_address)</td></tr>
<tr class="memdesc:a4b159c70569ac198acd7cd6a46a8d30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a complete 16-bit program word from memory.  <br /></td></tr>
<tr class="separator:a4b159c70569ac198acd7cd6a46a8d30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166877529469b5caa7d9ebf84c04cacf" id="r_a166877529469b5caa7d9ebf84c04cacf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avrprog_8c.html#a166877529469b5caa7d9ebf84c04cacf">avr_write_temporary_buffer_page</a> (uint16_t *data, size_t data_len)</td></tr>
<tr class="memdesc:a166877529469b5caa7d9ebf84c04cacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the entire temporary page buffer from an array.  <br /></td></tr>
<tr class="separator:a166877529469b5caa7d9ebf84c04cacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00148ce9a1b4ce673524d31e20ff7e9" id="r_af00148ce9a1b4ce673524d31e20ff7e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avrprog_8c.html#af00148ce9a1b4ce673524d31e20ff7e9">avr_verify_program_memory_page</a> (uint16_t page_address_start, uint16_t *expected_data, size_t data_len)</td></tr>
<tr class="memdesc:af00148ce9a1b4ce673524d31e20ff7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify programmed data by reading back and comparing.  <br /></td></tr>
<tr class="separator:af00148ce9a1b4ce673524d31e20ff7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af8bb7ec740999810f59f73277774f8a4" id="r_af8bb7ec740999810f59f73277774f8a4"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avrprog_8c.html#af8bb7ec740999810f59f73277774f8a4">output_buffer</a> [4] = {0,0,0,0}</td></tr>
<tr class="memdesc:af8bb7ec740999810f59f73277774f8a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI transaction output buffer.  <br /></td></tr>
<tr class="separator:af8bb7ec740999810f59f73277774f8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78fa4dbf1d9ed4f3f592d00eb0ba92e" id="r_ae78fa4dbf1d9ed4f3f592d00eb0ba92e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avrprog_8c.html#ae78fa4dbf1d9ed4f3f592d00eb0ba92e">erase_c</a> = 0</td></tr>
<tr class="memdesc:ae78fa4dbf1d9ed4f3f592d00eb0ba92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase counter for flash protection.  <br /></td></tr>
<tr class="separator:ae78fa4dbf1d9ed4f3f592d00eb0ba92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>AVR ISP (In-System Programming) implementation for Raspberry Pi Pico. </p>
<p>This file implements the low-level AVR ISP protocol using SPI hardware on the RP2040. It provides functions to communicate with AVR microcontrollers for:</p><ul>
<li>Reading device signatures (chip identification)</li>
<li>Entering/leaving programming mode</li>
<li>Erasing flash memory (chip erase)</li>
<li>Writing data to the temporary page buffer</li>
<li>Flashing page buffer contents to program memory</li>
<li>Reading back program memory for verification</li>
</ul>
<p>The implementation follows the Atmel AVR ISP protocol specification which uses 4-byte SPI transactions for all commands. The protocol runs over SPI Mode 0 (CPOL=0, CPHA=0) with the target held in reset during programming.</p>
<p>Reference: Atmel AVR ISP Programming Specification</p>
<dl class="section author"><dt>Author</dt><dd>MUdroThe1 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2026 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="acfc4cfb84dfc8dce803ec1517c6bf00b" name="acfc4cfb84dfc8dce803ec1517c6bf00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc4cfb84dfc8dce803ec1517c6bf00b">&#9670;&#160;</a></span>avr_enter_programming_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool avr_enter_programming_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enter AVR Serial Programming mode. </p>
<p>Enter Serial Programming mode.</p>
<p>Places the AVR target into Serial Programming mode by holding RESET low and sending the "Programming Enable" command. The target acknowledges successful entry by echoing 0x53 in the third byte of the response.</p>
<p>Programming Enable Command: 0xAC 0x53 0x00 0x00</p><ul>
<li>Byte 0: Programming Enable instruction (0xAC)</li>
<li>Byte 1: Signature byte (0x53)</li>
<li>Byte 2: Don't care (0x00)</li>
<li>Byte 3: Don't care (0x00)</li>
</ul>
<p>Expected Response:</p><ul>
<li>Byte 2 should echo 0x53 if successful</li>
</ul>
<p>The function retries up to 8 times before giving up, as per datasheet recommendation: "If the 0x53 did not echo back, give RESET a positive
pulse and issue a new Programming Enable command."</p>
<dl class="section return"><dt>Returns</dt><dd>true if programming mode was entered successfully, false otherwise </dd></dl>

</div>
</div>
<a id="a06815cdb67fe3043b8de01c367b8ca8d" name="a06815cdb67fe3043b8de01c367b8ca8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06815cdb67fe3043b8de01c367b8ca8d">&#9670;&#160;</a></span>avr_erase_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avr_erase_memory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a Chip Erase operation on the AVR target. </p>
<p>Perform Chip Erase operation.</p>
<p>Erases the entire flash memory and EEPROM of the AVR target. This operation MUST be performed before programming new data, as flash memory can only transition bits from 1 to 0 during programming - erase sets all bits to 1.</p>
<p>Chip Erase Command: 0xAC 0x80 0x00 0x00</p><ul>
<li>Byte 0: Chip Erase instruction (0xAC)</li>
<li>Byte 1: Erase code (0x80)</li>
<li>Bytes 2-3: Don't care (0x00)</li>
</ul>
<p>WARNING: This operation is DESTRUCTIVE to flash storage and contributes to flash wear. AVR flash typically supports ~10,000 erase/write cycles. A safety limit of 200 erases per session is enforced to prevent runaway erase loops from wearing out the target's flash.</p>
<p>Post-erase delay: 9ms minimum (as specified in AVR datasheets) </p>

</div>
</div>
<a id="ac2f5de25e840fe820d2c63b3c77f2b60" name="ac2f5de25e840fe820d2c63b3c77f2b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f5de25e840fe820d2c63b3c77f2b60">&#9670;&#160;</a></span>avr_flash_program_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avr_flash_program_memory </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>word_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flash the temporary page buffer to program memory. </p>
<p>Commit page buffer to flash memory.</p>
<p>After filling the temporary page buffer using <a class="el" href="avrprog_8h.html#ad5fea5f4158f65ac28f33dcb868834a8" title="Write low and high bytes separately to page buffer.">avr_write_temporary_buffer()</a>, this function commits the buffer contents to flash memory at the specified page address. The page address determines which flash page is written.</p>
<p>Write Program Memory Page Command: 0x4C &lt;addr_hi&gt; &lt;addr_lo&gt; 0x00</p><ul>
<li>Byte 0: Write Program Memory Page instruction (0x4C)</li>
<li>Bytes 1-2: Page address (word address, upper bits select page)</li>
<li>Byte 3: Don't care (0x00)</li>
</ul>
<p>The lower address bits within a page are ignored - the entire page buffer is written to the page boundary determined by the upper address bits.</p>
<p>Post-write delay: 5ms (datasheet specifies minimum 4.5ms for page write)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word_address</td><td>Word address that falls within the target page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2192cd51a3038bb9b1168ca1017e2582" name="a2192cd51a3038bb9b1168ca1017e2582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2192cd51a3038bb9b1168ca1017e2582">&#9670;&#160;</a></span>avr_leave_programming_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avr_leave_programming_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit AVR Serial Programming mode. </p>
<p>Exit Serial Programming mode.</p>
<p>Releases the RESET line (drives it high) to allow the AVR target to exit programming mode and begin normal execution. The target will start running its programmed firmware after RESET is released. </p>

</div>
</div>
<a id="a4b159c70569ac198acd7cd6a46a8d30c" name="a4b159c70569ac198acd7cd6a46a8d30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b159c70569ac198acd7cd6a46a8d30c">&#9670;&#160;</a></span>avr_read_program_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t avr_read_program_memory </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>word_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a complete 16-bit program word from memory. </p>
<p>Read complete 16-bit program word.</p>
<p>Convenience function that reads both the low and high bytes of a program word and combines them into a single 16-bit value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word_address</td><td>Word address to read (not byte address) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>16-bit program word (high byte &lt;&lt; 8 | low byte) </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="avrprog_8c_a4b159c70569ac198acd7cd6a46a8d30c_cgraph.svg" width="464" height="115"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="avrprog_8c_a4b159c70569ac198acd7cd6a46a8d30c_icgraph.svg" width="411" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ab140e6a9e9d9a0b28c1669db8f4ef47e" name="ab140e6a9e9d9a0b28c1669db8f4ef47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab140e6a9e9d9a0b28c1669db8f4ef47e">&#9670;&#160;</a></span>avr_read_program_memory_high_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t avr_read_program_memory_high_byte </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>word_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the high byte of a program memory word. </p>
<p>Read high byte of program word.</p>
<p>Reads the upper 8 bits of a 16-bit program word at the specified address.</p>
<p>Read Program Memory (High Byte) Command: 0x28 &lt;addr_hi&gt; &lt;addr_lo&gt; 0x00</p><ul>
<li>Response byte 3 contains the high byte of the program word</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word_address</td><td>Word address to read (not byte address) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Upper 8 bits of the program word at the specified address </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="avrprog_8c_ab140e6a9e9d9a0b28c1669db8f4ef47e_icgraph.svg" width="662" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a4001d4bd58bb212246ad73ea16c7718a" name="a4001d4bd58bb212246ad73ea16c7718a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4001d4bd58bb212246ad73ea16c7718a">&#9670;&#160;</a></span>avr_read_program_memory_low_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t avr_read_program_memory_low_byte </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>word_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the low byte of a program memory word. </p>
<p>Read low byte of program word.</p>
<p>Reads the lower 8 bits of a 16-bit program word at the specified address.</p>
<p>Read Program Memory (Low Byte) Command: 0x20 &lt;addr_hi&gt; &lt;addr_lo&gt; 0x00</p><ul>
<li>Response byte 3 contains the low byte of the program word</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word_address</td><td>Word address to read (not byte address) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Lower 8 bits of the program word at the specified address </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="avrprog_8c_a4001d4bd58bb212246ad73ea16c7718a_icgraph.svg" width="662" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aee655c0c64cc3dea8a411bec014c0cdf" name="aee655c0c64cc3dea8a411bec014c0cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee655c0c64cc3dea8a411bec014c0cdf">&#9670;&#160;</a></span>avr_read_signature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avr_read_signature </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the 3-byte device signature from the AVR. </p>
<p>Read 3-byte device signature.</p>
<p>The device signature uniquely identifies the AVR chip (manufacturer, family, and specific part). This is used to auto-detect page sizes and verify the correct target is connected.</p>
<p>ISP Command Format: 0x30 0x00 &lt;addr&gt; 0x00</p><ul>
<li>Byte 0: Read Signature Byte instruction (0x30)</li>
<li>Byte 1: Always 0x00</li>
<li>Byte 2: Signature byte address (0, 1, or 2)</li>
<li>Byte 3: Don't care (0x00)</li>
</ul>
<p>Response: The signature byte is returned in the 4th byte of the SPI response.</p>
<p>Example signatures:</p><ul>
<li>ATmega328P: 0x1E 0x95 0x0F</li>
<li>ATtiny85: 0x1E 0x93 0x0B</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signature</td><td>Pointer to a 3-byte buffer to store the signature </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20f4037696b714b05489fda5207a0231" name="a20f4037696b714b05489fda5207a0231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f4037696b714b05489fda5207a0231">&#9670;&#160;</a></span>avr_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avr_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a hardware reset pulse on the AVR target. </p>
<p>Pulse RESET line to restart target.</p>
<p>Generates an active-low reset pulse to restart the AVR target. This is useful for resetting the target after programming or for recovery from stuck states.</p>
<p>Timing:</p><ul>
<li>RESET held low for 20ms</li>
<li>RESET released high for 20ms before returning </li>
</ul>

</div>
</div>
<a id="afd14f08aed255cec267160466dcc769f" name="afd14f08aed255cec267160466dcc769f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd14f08aed255cec267160466dcc769f">&#9670;&#160;</a></span>avr_spi_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avr_spi_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the SPI interface for AVR ISP communication. </p>
<p>Initialize SPI interface for AVR ISP communication.</p>
<p>This function configures the RP2040's SPI0 peripheral and associated GPIO pins for communication with an AVR target in ISP mode.</p>
<p>SPI Configuration:</p><ul>
<li>Frequency: 50kHz (conservative to support slow-clocked AVRs)</li>
<li>Mode 0: CPOL=0 (clock idle low), CPHA=0 (sample on rising edge)</li>
<li>Data order: MSB first (standard for AVR ISP)</li>
<li>Data bits: 8</li>
</ul>
<p>Note: The SPI frequency is intentionally kept low (50kHz) to support AVR targets running with the CKDIV8 fuse set (1MHz internal clock / 8 = 125kHz). ISP clock should be less than 1/4 of the target's system clock. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="avrprog_8c_afd14f08aed255cec267160466dcc769f_icgraph.svg" width="211" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="af00148ce9a1b4ce673524d31e20ff7e9" name="af00148ce9a1b4ce673524d31e20ff7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00148ce9a1b4ce673524d31e20ff7e9">&#9670;&#160;</a></span>avr_verify_program_memory_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool avr_verify_program_memory_page </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>page_address_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>expected_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify programmed data by reading back and comparing. </p>
<p>Verify programmed page against expected data.</p>
<p>Reads back a page of program memory and compares it against expected data. This verification step is critical because flash writes can fail silently, especially at the limits of voltage/temperature specifications.</p>
<p>Best practice: Always verify after programming each page and retry if verification fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_address_start</td><td>Starting word address of the page to verify </td></tr>
    <tr><td class="paramname">expected_data</td><td>Pointer to array of expected 16-bit program words </td></tr>
    <tr><td class="paramname">data_len</td><td>Number of words to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all words match expected data, false if any mismatch </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="avrprog_8c_af00148ce9a1b4ce673524d31e20ff7e9_cgraph.svg" width="662" height="115"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ad5fea5f4158f65ac28f33dcb868834a8" name="ad5fea5f4158f65ac28f33dcb868834a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fea5f4158f65ac28f33dcb868834a8">&#9670;&#160;</a></span>avr_write_temporary_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avr_write_temporary_buffer </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>word_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>low_byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>high_byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a word (low and high bytes) to the temporary page buffer. </p>
<p>Write low and high bytes separately to page buffer.</p>
<p>AVR flash programming uses a page buffer model:</p><ol type="1">
<li>Fill the temporary page buffer with data (this function)</li>
<li>Issue a page write command to flash the buffer to memory</li>
</ol>
<p>Load Program Memory Page Commands:</p><ul>
<li>Low byte: 0x40 &lt;addr_hi&gt; &lt;addr_lo&gt; &lt;data&gt;</li>
<li>High byte: 0x48 &lt;addr_hi&gt; &lt;addr_lo&gt; &lt;data&gt;</li>
</ul>
<p>Note: Addresses are WORD addresses (2 bytes per word), not byte addresses. The page buffer size varies by device (e.g., 32 words for ATtiny, 64 words for ATmega328P).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word_address</td><td>Word address within the page (0 to page_size/2 - 1) </td></tr>
    <tr><td class="paramname">low_byte</td><td>Lower 8 bits of the program word </td></tr>
    <tr><td class="paramname">high_byte</td><td>Upper 8 bits of the program word </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="avrprog_8c_ad5fea5f4158f65ac28f33dcb868834a8_icgraph.svg" width="583" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a3f08500e8dc958684c90401d71ee4e79" name="a3f08500e8dc958684c90401d71ee4e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f08500e8dc958684c90401d71ee4e79">&#9670;&#160;</a></span>avr_write_temporary_buffer_16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avr_write_temporary_buffer_16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>word_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a 16-bit word to the temporary page buffer. </p>
<p>Write a 16-bit word to page buffer.</p>
<p>Convenience wrapper for <a class="el" href="avrprog_8h.html#ad5fea5f4158f65ac28f33dcb868834a8" title="Write low and high bytes separately to page buffer.">avr_write_temporary_buffer()</a> that accepts a single 16-bit word instead of separate low/high bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word_address</td><td>Word address within the page buffer </td></tr>
    <tr><td class="paramname">word</td><td>16-bit program word (little-endian: low byte first in memory) </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="avrprog_8c_a3f08500e8dc958684c90401d71ee4e79_cgraph.svg" width="376" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="avrprog_8c_a3f08500e8dc958684c90401d71ee4e79_icgraph.svg" width="376" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a166877529469b5caa7d9ebf84c04cacf" name="a166877529469b5caa7d9ebf84c04cacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a166877529469b5caa7d9ebf84c04cacf">&#9670;&#160;</a></span>avr_write_temporary_buffer_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avr_write_temporary_buffer_page </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the entire temporary page buffer from an array. </p>
<p>Fill page buffer from array.</p>
<p>Writes multiple 16-bit words to the temporary page buffer starting from address 0. This is more efficient than individual writes when programming a complete page.</p>
<p>The caller must ensure data_len does not exceed the device's page size (in words). Common page sizes:</p><ul>
<li>ATtiny84/85: 32 words (64 bytes)</li>
<li>ATmega328P: 64 words (128 bytes)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array of 16-bit program words </td></tr>
    <tr><td class="paramname">data_len</td><td>Number of words to write (must not exceed device page size) </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="avrprog_8c_a166877529469b5caa7d9ebf84c04cacf_cgraph.svg" width="583" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae78fa4dbf1d9ed4f3f592d00eb0ba92e" name="ae78fa4dbf1d9ed4f3f592d00eb0ba92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78fa4dbf1d9ed4f3f592d00eb0ba92e">&#9670;&#160;</a></span>erase_c</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int erase_c = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase counter for flash protection. </p>
<p>Tracks the number of erase operations performed in the current session. AVR flash has a limited erase/write endurance (typically ~10,000 cycles). This counter provides protection against accidental infinite erase loops that could wear out the flash prematurely. </p>

</div>
</div>
<a id="af8bb7ec740999810f59f73277774f8a4" name="af8bb7ec740999810f59f73277774f8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bb7ec740999810f59f73277774f8a4">&#9670;&#160;</a></span>output_buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t output_buffer[4] = {0,0,0,0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI transaction output buffer. </p>
<p>All AVR ISP commands are 4-byte SPI transactions. This buffer holds the response data from the target during each transaction. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
