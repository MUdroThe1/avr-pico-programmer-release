/**
 * @file avrprog.c
 * @brief AVR ISP (In-System Programming) implementation for Raspberry Pi Pico
 * 
 * This file implements the low-level AVR ISP protocol using SPI hardware on the RP2040.
 * It provides functions to communicate with AVR microcontrollers for:
 *   - Reading device signatures (chip identification)
 *   - Entering/leaving programming mode
 *   - Erasing flash memory (chip erase)
 *   - Writing data to the temporary page buffer
 *   - Flashing page buffer contents to program memory
 *   - Reading back program memory for verification
 * 
 * The implementation follows the Atmel AVR ISP protocol specification which uses
 * 4-byte SPI transactions for all commands. The protocol runs over SPI Mode 0
 * (CPOL=0, CPHA=0) with the target held in reset during programming.
 * 
 * Reference: Atmel AVR ISP Programming Specification
 * 
 * @author MUdroThe1
 * @date 2026
 */

#include "avrprog.h"
#include <stdint.h>
#include <pico/stdlib.h>
#include <hardware/spi.h>
#include <stdio.h>

/*******************************************************************************
 * GPIO Pin Definitions for AVR ISP Interface
 * 
 * These pins connect the Pico to the AVR target's ISP header.
 * Standard 6-pin ISP header pinout:
 *   Pin 1: MISO    Pin 2: VCC
 *   Pin 3: SCK     Pin 4: MOSI
 *   Pin 5: RESET   Pin 6: GND
 ******************************************************************************/
#define mosi_pin 19     /* Master Out Slave In - data from Pico to AVR */
#define sck_pin 18      /* Serial Clock - generated by Pico (master) */
#define miso_pin 16     /* Master In Slave Out - data from AVR to Pico */
#define reset_pin 17    /* Active-low reset line to hold AVR in programming mode */
#define power_pin 0     /* Optional power control for target (not currently used) */

/**
 * @brief SPI transaction output buffer
 * 
 * All AVR ISP commands are 4-byte SPI transactions. This buffer holds
 * the response data from the target during each transaction.
 */
uint8_t output_buffer[4] = {0,0,0,0};


/**
 * @brief Read the 3-byte device signature from the AVR
 * 
 * The device signature uniquely identifies the AVR chip (manufacturer, family,
 * and specific part). This is used to auto-detect page sizes and verify the
 * correct target is connected.
 * 
 * ISP Command Format: 0x30 0x00 <addr> 0x00
 *   - Byte 0: Read Signature Byte instruction (0x30)
 *   - Byte 1: Always 0x00
 *   - Byte 2: Signature byte address (0, 1, or 2)
 *   - Byte 3: Don't care (0x00)
 * 
 * Response: The signature byte is returned in the 4th byte of the SPI response.
 * 
 * Example signatures:
 *   - ATmega328P: 0x1E 0x95 0x0F
 *   - ATtiny85:   0x1E 0x93 0x0B
 * 
 * @param signature Pointer to a 3-byte buffer to store the signature
 */
void avr_read_signature(uint8_t *signature) {
    for (int i = 0; i < 3; i++) {
        uint8_t cmd[4] = {0x30, 0x00, (uint8_t)i, 0x00};
        spi_write_read_blocking(spi0, cmd, output_buffer, 4);
        signature[i] = output_buffer[3];
    }
}

/**
 * @brief Initialize the SPI interface for AVR ISP communication
 * 
 * This function configures the RP2040's SPI0 peripheral and associated GPIO
 * pins for communication with an AVR target in ISP mode.
 * 
 * SPI Configuration:
 *   - Frequency: 50kHz (conservative to support slow-clocked AVRs)
 *   - Mode 0: CPOL=0 (clock idle low), CPHA=0 (sample on rising edge)
 *   - Data order: MSB first (standard for AVR ISP)
 *   - Data bits: 8
 * 
 * Note: The SPI frequency is intentionally kept low (50kHz) to support AVR
 * targets running with the CKDIV8 fuse set (1MHz internal clock / 8 = 125kHz).
 * ISP clock should be less than 1/4 of the target's system clock.
 */
void avr_spi_init() {
    /* Configure RESET pin as output, initially high (target not in reset) */
    gpio_init(reset_pin);
    gpio_set_dir(reset_pin, GPIO_OUT);
    gpio_put(reset_pin, 1);  /* High = target running normally */

    /* Configure SPI pins for hardware SPI0 peripheral */
    gpio_set_function(mosi_pin, GPIO_FUNC_SPI);  /* SPI0 TX */
    gpio_set_function(sck_pin, GPIO_FUNC_SPI);   /* SPI0 SCK */
    gpio_set_function(miso_pin, GPIO_FUNC_SPI);  /* SPI0 RX */

    /* Initialize SPI0 at 50kHz - slow enough for AVRs with CKDIV8 fuse */
    spi_init(spi0, 50000);

    /* Configure SPI Mode 0 as required by AVR ISP protocol */
    spi_set_format(spi0, 8, SPI_CPOL_0, SPI_CPHA_0, SPI_MSB_FIRST);
}

/**
 * @brief Perform a hardware reset pulse on the AVR target
 * 
 * Generates an active-low reset pulse to restart the AVR target.
 * This is useful for resetting the target after programming or
 * for recovery from stuck states.
 * 
 * Timing:
 *   - RESET held low for 20ms
 *   - RESET released high for 20ms before returning
 */
void avr_reset() {
    gpio_put(reset_pin, 0);   /* Assert reset (active low) */
    sleep_ms(20);             /* Hold reset for 20ms */
    gpio_put(reset_pin, 1);   /* Release reset */
    sleep_ms(20);             /* Wait for target to stabilize */
}

/**
 * @brief Enter AVR Serial Programming mode
 * 
 * Places the AVR target into Serial Programming mode by holding RESET low
 * and sending the "Programming Enable" command. The target acknowledges
 * successful entry by echoing 0x53 in the third byte of the response.
 * 
 * Programming Enable Command: 0xAC 0x53 0x00 0x00
 *   - Byte 0: Programming Enable instruction (0xAC)
 *   - Byte 1: Signature byte (0x53)
 *   - Byte 2: Don't care (0x00)
 *   - Byte 3: Don't care (0x00)
 * 
 * Expected Response:
 *   - Byte 2 should echo 0x53 if successful
 * 
 * The function retries up to 8 times before giving up, as per datasheet
 * recommendation: "If the 0x53 did not echo back, give RESET a positive
 * pulse and issue a new Programming Enable command."
 * 
 * @return true if programming mode was entered successfully, false otherwise
 */
bool avr_enter_programming_mode() {
    /* Ensure RESET starts high, then pull low to enter programming mode */
    gpio_put(reset_pin, 1);
    sleep_ms(2);
    gpio_put(reset_pin, 0);  /* Hold target in reset for programming */

    /* Programming Enable command with signature 0x53 */
    uint8_t cmd[4] = {0xAC, 0x53, 0x00, 0x00};
    
    /* Retry up to 8 times - target may need time to synchronize */
    for (int attempt = 0; attempt < 8; attempt++) {
        spi_write_read_blocking(spi0, cmd, output_buffer, 4);
        
        /* Success: target echoes 0x53 in third response byte */
        if (output_buffer[2] == 0x53) {
            return true;
        }
        sleep_ms(10);  /* Wait before retry */
    }

    /* Failed to enter programming mode - release reset and return failure */
    gpio_put(reset_pin, 1);
    sleep_ms(2);
    return false;
}

/**
 * @brief Exit AVR Serial Programming mode
 * 
 * Releases the RESET line (drives it high) to allow the AVR target to
 * exit programming mode and begin normal execution. The target will
 * start running its programmed firmware after RESET is released.
 */
void avr_leave_programming_mode() {
    gpio_put(reset_pin, 1);  /* Release reset - target starts running */
    sleep_ms(2);             /* Brief delay for target stabilization */
}

/**
 * @brief Erase counter for flash protection
 * 
 * Tracks the number of erase operations performed in the current session.
 * AVR flash has a limited erase/write endurance (typically ~10,000 cycles).
 * This counter provides protection against accidental infinite erase loops
 * that could wear out the flash prematurely.
 */
int erase_c = 0;

/**
 * @brief Perform a Chip Erase operation on the AVR target
 * 
 * Erases the entire flash memory and EEPROM of the AVR target. This operation
 * MUST be performed before programming new data, as flash memory can only
 * transition bits from 1 to 0 during programming - erase sets all bits to 1.
 * 
 * Chip Erase Command: 0xAC 0x80 0x00 0x00
 *   - Byte 0: Chip Erase instruction (0xAC)
 *   - Byte 1: Erase code (0x80)
 *   - Bytes 2-3: Don't care (0x00)
 * 
 * WARNING: This operation is DESTRUCTIVE to flash storage and contributes
 * to flash wear. AVR flash typically supports ~10,000 erase/write cycles.
 * A safety limit of 200 erases per session is enforced to prevent runaway
 * erase loops from wearing out the target's flash.
 * 
 * Post-erase delay: 9ms minimum (as specified in AVR datasheets)
 */
void avr_erase_memory() {
    /* Safety check: prevent infinite erase loops from wearing out flash */
    if (erase_c > 200) {
        printf("the erase operation has been performed more than 200 times in this session!\n"
               "to protect the flash from a potential infinite erase loop the program has been halted\n");
        while (true) sleep_ms(100);  /* Halt execution */
    }

    /* Send Chip Erase command */
    uint8_t cmd[4] = {0xAC, 0x80, 0x00, 0x00};
    spi_write_read_blocking(spi0, cmd, output_buffer, 4);
    
    /* Wait for erase to complete - minimum 9ms per datasheet */
    sleep_ms(9);

    erase_c++;  /* Track erase count for safety */
}

/**
 * @brief Write a word (low and high bytes) to the temporary page buffer
 * 
 * AVR flash programming uses a page buffer model:
 *   1. Fill the temporary page buffer with data (this function)
 *   2. Issue a page write command to flash the buffer to memory
 * 
 * Load Program Memory Page Commands:
 *   - Low byte:  0x40 <addr_hi> <addr_lo> <data>
 *   - High byte: 0x48 <addr_hi> <addr_lo> <data>
 * 
 * Note: Addresses are WORD addresses (2 bytes per word), not byte addresses.
 * The page buffer size varies by device (e.g., 32 words for ATtiny, 64 words for ATmega328P).
 * 
 * @param word_address Word address within the page (0 to page_size/2 - 1)
 * @param low_byte     Lower 8 bits of the program word
 * @param high_byte    Upper 8 bits of the program word
 */
void avr_write_temporary_buffer(uint16_t word_address, uint8_t low_byte, uint8_t high_byte) {
    uint8_t addr_msb = word_address >> 8;        /* High byte of word address */
    uint8_t addr_lsb = word_address & 0xFF;      /* Low byte of word address */

    /* Load Program Memory Page (Low Byte): 0x40 */
    uint8_t cmd[4] = {0x40, addr_msb, addr_lsb, low_byte};
    spi_write_read_blocking(spi0, cmd, output_buffer, 4);

    /* Load Program Memory Page (High Byte): 0x48 */
    uint8_t cmd2[4] = {0x48, addr_msb, addr_lsb, high_byte};
    spi_write_read_blocking(spi0, cmd2, output_buffer, 4);
}

/**
 * @brief Write a 16-bit word to the temporary page buffer
 * 
 * Convenience wrapper for avr_write_temporary_buffer() that accepts
 * a single 16-bit word instead of separate low/high bytes.
 * 
 * @param word_address Word address within the page buffer
 * @param word         16-bit program word (little-endian: low byte first in memory)
 */
void avr_write_temporary_buffer_16(uint16_t word_address, uint16_t word) {
    avr_write_temporary_buffer(word_address, word & 0xFF, word >> 8);
}

/**
 * @brief Flash the temporary page buffer to program memory
 * 
 * After filling the temporary page buffer using avr_write_temporary_buffer(),
 * this function commits the buffer contents to flash memory at the specified
 * page address. The page address determines which flash page is written.
 * 
 * Write Program Memory Page Command: 0x4C <addr_hi> <addr_lo> 0x00
 *   - Byte 0: Write Program Memory Page instruction (0x4C)
 *   - Bytes 1-2: Page address (word address, upper bits select page)
 *   - Byte 3: Don't care (0x00)
 * 
 * The lower address bits within a page are ignored - the entire page buffer
 * is written to the page boundary determined by the upper address bits.
 * 
 * Post-write delay: 5ms (datasheet specifies minimum 4.5ms for page write)
 * 
 * @param word_address Word address that falls within the target page
 */
void avr_flash_program_memory(uint16_t word_address) {
    uint8_t addr_msb = word_address >> 8;    /* High byte of word address */
    uint8_t addr_lsb = word_address & 0xFF;  /* Low byte of word address */

    /* Write Program Memory Page: 0x4C */
    uint8_t cmd[4] = {0x4C, addr_msb, addr_lsb, 0x0};
    spi_write_read_blocking(spi0, cmd, output_buffer, 4);

    /* Wait for page write to complete - minimum 4.5ms per datasheet */
    sleep_ms(5);
}

/**
 * @brief Read the low byte of a program memory word
 * 
 * Reads the lower 8 bits of a 16-bit program word at the specified address.
 * 
 * Read Program Memory (Low Byte) Command: 0x20 <addr_hi> <addr_lo> 0x00
 *   - Response byte 3 contains the low byte of the program word
 * 
 * @param word_address Word address to read (not byte address)
 * @return Lower 8 bits of the program word at the specified address
 */
uint8_t avr_read_program_memory_low_byte(uint16_t word_address) {
    uint8_t addr_msb = word_address >> 8;    /* High byte of word address */
    uint8_t addr_lsb = word_address & 0xFF;  /* Low byte of word address */

    /* Read Program Memory (Low Byte): 0x20 */
    uint8_t cmd[4] = {0x20, addr_msb, addr_lsb, 0x0};
    spi_write_read_blocking(spi0, cmd, output_buffer, 4);

    return output_buffer[3];  /* Data returned in 4th byte */
}

/**
 * @brief Read the high byte of a program memory word
 * 
 * Reads the upper 8 bits of a 16-bit program word at the specified address.
 * 
 * Read Program Memory (High Byte) Command: 0x28 <addr_hi> <addr_lo> 0x00
 *   - Response byte 3 contains the high byte of the program word
 * 
 * @param word_address Word address to read (not byte address)
 * @return Upper 8 bits of the program word at the specified address
 */
uint8_t avr_read_program_memory_high_byte(uint16_t word_address) {
    uint8_t addr_msb = word_address >> 8;    /* High byte of word address */
    uint8_t addr_lsb = word_address & 0xFF;  /* Low byte of word address */

    /* Read Program Memory (High Byte): 0x28 */
    uint8_t cmd[4] = {0x28, addr_msb, addr_lsb, 0x0};
    spi_write_read_blocking(spi0, cmd, output_buffer, 4);

    return output_buffer[3];  /* Data returned in 4th byte */
}

/**
 * @brief Read a complete 16-bit program word from memory
 * 
 * Convenience function that reads both the low and high bytes of a program
 * word and combines them into a single 16-bit value.
 * 
 * @param word_address Word address to read (not byte address)
 * @return 16-bit program word (high byte << 8 | low byte)
 */
uint16_t avr_read_program_memory(uint16_t word_address) {
    uint16_t data;

    /* Read high byte first, then low byte */
    data = avr_read_program_memory_high_byte(word_address);
    data <<= 8;  /* Shift high byte to upper position */
    data |= avr_read_program_memory_low_byte(word_address);

    return data;
}

/**
 * @brief Fill the entire temporary page buffer from an array
 * 
 * Writes multiple 16-bit words to the temporary page buffer starting from
 * address 0. This is more efficient than individual writes when programming
 * a complete page.
 * 
 * The caller must ensure data_len does not exceed the device's page size
 * (in words). Common page sizes:
 *   - ATtiny84/85: 32 words (64 bytes)
 *   - ATmega328P:  64 words (128 bytes)
 * 
 * @param data     Pointer to array of 16-bit program words
 * @param data_len Number of words to write (must not exceed device page size)
 */
void avr_write_temporary_buffer_page(uint16_t* data, size_t data_len) {
    if (data_len == 0) return;

    /* Write each word to sequential addresses in the page buffer */
    for (size_t i = 0; i < data_len; i++) {
        avr_write_temporary_buffer_16((uint16_t)i, data[i]);
    }
}

/**
 * @brief Verify programmed data by reading back and comparing
 * 
 * Reads back a page of program memory and compares it against expected data.
 * This verification step is critical because flash writes can fail silently,
 * especially at the limits of voltage/temperature specifications.
 * 
 * Best practice: Always verify after programming each page and retry if
 * verification fails.
 * 
 * @param page_address_start Starting word address of the page to verify
 * @param expected_data      Pointer to array of expected 16-bit program words
 * @param data_len           Number of words to verify
 * @return true if all words match expected data, false if any mismatch
 */
bool avr_verify_program_memory_page(uint16_t page_address_start, uint16_t* expected_data, size_t data_len) {
    for (size_t i = 0; i < data_len; i++) {
        uint16_t word = avr_read_program_memory(page_address_start + i);
        if (word != expected_data[i]) {
            return false;  /* Verification failed - mismatch detected */
        }
    }

    return true;  /* All words verified successfully */
}
